#include "tftp.h"

/*a function to print the Help menu*/
void help (char *);

/*a function to create the request packet, read or write*/
int req_packet (int opcode, char *filename, char *mode, char buf[]);
/*a function to creat an ACK packet*/
int ack_packet (int block, char buf[]);
/*a function to create the Error packets*/
int err_packet (int err_code, char *err_msg, char buf[]);
/*a function that will print the ip:port pair of the server or client, plus data sent or recieved*/
void ip_port (struct sockaddr_in host);
/*a function to send a file to the server*/
void tsend (char *pFilename, struct sockaddr_in server, char *pMode,
		int sock);
/*a function to get a file from the server*/
void tget (char *pFilename, struct sockaddr_in server, char *pMode, int sock);


/* default values which can be controlled by command line */
char path[64] = "/home/ravi/tftp-1.0/";
int port = 71;
unsigned short int ackfreq = 1;
int datasize = 512;
int debug = 1, w_size = 1, p_length = 512;


int main (int argc, char **argv)
{
	int sock, server_len, len, opt;
	char opcode, filename[196], mode[12] = "octet";
	struct hostent *host;
	struct sockaddr_in server;
	char* host_ip = "127.0.0.1";
	FILE *fp;

	if (argc < 2)
	{
		printf("invalid format of command\n");
		return 0;
	}

	while ((opt = getopt (argc, argv, "h:P:p:g:l:w:")) != -1)
	{
		// printf("inside first while \n");
		switch (opt)
		{
			case 'h':
				host_ip = optarg;
				printf("server ip is %s\n", host_ip);
				break;			
			case 'P':		// get port number
				port = atoi (optarg);
				printf ("Client: The port number is: %d\n", port);
				break;
			case 'p':
//				printf("need to put a file in server\n\n");
				strncpy (filename, optarg, sizeof (filename) - 1);
				opcode = WRQ;
				// fp = fopen (filename, "r");	
				// if (fp == NULL)
				// {
				// 	printf ("Client: file could not be opened\n");
				// 	return 0;
				// }
				// printf ("Client: The file name is: %s and can be read", filename);
				// fclose (fp);
				break;

			case 'g':
				strncpy (filename, optarg, sizeof (filename) - 1);
				opcode = RRQ;
				// fp = fopen (filename, "w");	/*opened the file for writting */
				// if (fp == NULL)
				// {
				// 	printf ("Client: file could not be created\n");
				// 	return 0;
				// }
				// printf ("Client: The file name is: %s and it has been created", filename);
				// fclose (fp);
				break;

			// case 'w':		/* Get the window size */
			// 	ackfreq = atoi (optarg);
			// 	if (debug)
			// 	{
			// 		printf ("Client: Window size is: %i\n", ackfreq);
			// 	}
			// 	//ackfreq = atoi (optarg);
			// 	if (ackfreq > MAXACKFREQ)
			// 	{
			// 		printf
			// 			("Client: Sorry, you specified an ack frequency higher than the maximum allowed (Requested: %d Max: %d)\n",
			// 			 ackfreq, MAXACKFREQ);
			// 		return 0;
			// 	}
			// 	else if (w_size == 0)
			// 	{
			// 		printf ("Client: Sorry, you have to ack sometime.\n");
			// 		return 0;
			// 	}
			// 	break;

			// case 'l':		/* packet length */
			// 	datasize = atoi (optarg);
			// 	if (debug)
			// 	{
			// 		printf ("Client: Packet length is: %i bytes\n", datasize);
			// 	}
			// 	if (datasize > MAXDATASIZE)
			// 	{
			// 		printf
			// 			("Client: Sorry, you specified a data size higher than the maximum allowed (Requested: %d Max: %d)\n",
			// 			 datasize, MAXDATASIZE);
			// 		return 0;
			// 	}
			// 	break;

			// case 'H':		/* Help (no opts) */
			// 	help (argv[0]);
			// 	return (0);
			// 	break;
			case 'o':
				strncpy (mode, "octet", sizeof (mode) - 1);
				printf ("Client: The mode is set to octet\n");
				break;
			case 'n':
				strncpy (mode, "netascii", sizeof (mode) - 1);
				printf ("Client: The mode is set to netascii\n");
				break;
			default:
				printf("invalid option in command.Please refer to syntax of command\n");
				return (0);
				break;
		}
	}

	// printf("outside while \n");
	if (!(host = gethostbyname (host_ip)))
	{
		perror ("could not obtain host address as");
		exit (2);
	}

	printf("opening file in required mode \n");
	if(opcode == WRQ)
		fp = fopen (filename, "r");	
	else if(opcode == RRQ)
		fp = fopen (filename, "w");		
	if (fp == NULL){
		printf ("Client: file could not be opened\n");
		return 0;
	}
	if(opcode == WRQ)
		printf ("Client: The file name is: %s and can be read\n", filename);
	else if(opcode == RRQ)
		printf ("Client: The file name is: %s and it has been created\n", filename);
	fclose (fp);		


	/*Create the socket, a -1 will show us an error */
	if ((sock = socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)
	{
		printf ("client: socket");
		return 0;
	}

	 // bind to an arbitrary return address 
	 // because this is the client side, we don't care about the 
	 // address since no application will connect here  
	 // INADDR_ANY is the IP address and 0 is the socket 
	 // htonl converts a long integer (e.g. address) to a network 
	 // representation (agreed-upon byte ordering 

	bzero(&server, sizeof (server));
	server.sin_family = AF_INET;
	memcpy (&server.sin_addr, host->h_addr, host->h_length);
	// server.sin_addr.s_addr = htonl (INADDR_ANY);
	server.sin_port = htons (port);	


	server_len = sizeof (server);
	//printf("value os BUFSIZ is %d \n", BUFSIZ);
	memset (buf, 0, BUFSIZ);
	// creates RRQ packet
	len = req_packet (opcode, filename, mode, buf);

	if (sendto (sock, buf, len, 0, (struct sockaddr *) &server, server_len) != len)
	{
		perror ("Client: sendto has returend an error");
		exit(-1);
	}
	if (debug)
		ip_port (server);
	switch (opcode)
	{
		case RRQ:
			tget (filename, server, mode, sock);
			break;
		case WRQ:
			tsend (filename, server, mode, sock);
			break;
		default:
			printf ("Invalid opcode. Packet discarded.");
	}
	close (sock);
	return 1;
}

// void help (char *app)
// {
// 	printf
// 		("Usage:\n%s server [-h] [-d] [-P port] [-g] | [-p] [file-name] [-w size] [-l length] [-o] [-n]\n",
// 		 app);
// 	printf
// 		("Options:\n-h (help; this message)\n-d (Debug mode)\n-P port(Port number default is 69)\n-g (get a file from the server)\n-p (send a file to the server)\n");
// 	printf
// 		("-w size (set window size, default is 1)\n-l len (set max packet length, default is 512 bytes)\n");
// 	printf
// 		("-o for octet file transfer (default).\n-n for netascii file transfer\n");
// }


// creates a request packet and returns lenght of packet
int req_packet (int opcode, char *filename, char *mode, char header[])
{
	int lenght;
	// format is for RRQ/WRQ : | 01/02 | Filename | 0 | Mode | 0
	lenght = sprintf (header, "%c%c%s%c%s%c", 0x00, opcode, filename, 0x00, mode, 0x00);
	if (lenght == 0)
	{
		printf ("Error in creating the request packet\n");	/*could not print to the client buffer */
		exit(-1);
	}
	printf ("RRQ packet created.\n");
	return lenght;
}


// creates a request packet and returns length of packet
int ack_packet (int block, char buf[])
{
	int packet_len;
	packet_len = sprintf (buf, "%c%c%c%c", 0x00, ACK, 0x00, 0x00);
	buf[2] = (block & 0xFF00) >> 8;
	buf[3] = (block & 0x00FF);
	if (packet_len == 0)
	{
		printf ("Error in creating the ACK packet\n");
		exit(-1);ved less 4 then it didn't work 
	while (fwrite (filebuf, 1, n - 4, fp) == n - 4);
	fclose (fp);
	sync ();
	printf("file failed to recieve properly\n");
	return;

done:

	fclose (fp);
	sync ();
	if (debug)
		printf ("File received successfully\n");
	return;
}
